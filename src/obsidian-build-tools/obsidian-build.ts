#!/usr/bin/env node

import { existsSync } from "fs";
import path from "path";
import process from "process";
import { OutputOptions, RollupError, RollupOptions, RollupWatcher, rollup, watch } from "rollup";
import { clearScreen, defineConfigs, dim, green, red } from "./lib";

/**
 * The configuration options from the config file.
 */
interface ObsidianOptions {
    /** The folder that contains the source files to build. */
    source?: string;

    /** If set then the bundled files will be copied to this path. */
    copy: string;
};

/**
 * Displays an error from rollup. This is patterned to display it the same way
 * it would be if it was generated by rollup directly.
 * 
 * @param error The error that should be displayed.
 */
function displayError(error: RollupError): void {
    let description = error.message || error;
    if (error.name) {
        description = `${error.name}: ${description}`;
    }

    if (error.plugin) {
        description = `(plugin ${error.plugin}) ${description}`;
    }

    process.stderr.write(`${red(`[!] ${description}`)}\n`); // red

    if (error.loc) {
        process.stderr.write(`${path.relative(process.cwd(), error.loc.file)} (${error.loc.line}:${error.loc.column})\n`);
    }

    if (error.stack) {
        process.stderr.write(`${dim(error.stack)}\n`);
    }
}

/**
 * Configures the watcher by observing various events and responding to them.
 * 
 * @param watcher The rollup watcher that will be configured.
 */
function configureWatcher(watcher: RollupWatcher): void {
    watcher.on("event", ev => {
        // A new build has started.
        if (ev.code === "START") {
            clearScreen();
            process.stdout.write("starting build.\n");
        }

        // A build has completed.
        else if (ev.code === "END") {
            const date = new Date();
            const dateString = date
                .toISOString()
                .replace(/T/, " ")
                .replace(/\..+/, "");
            process.stdout.write(`\n[${dateString}] waiting for changes...\n`);
        }

        // A build has started for a single bundle.
        else if (ev.code === "BUNDLE_START") {
            process.stdout.write("\n");
        }
        
        // A build has completed for a single bundle.
        else if (ev.code === "BUNDLE_END") {
            if (typeof ev.input !== "string") {
                throw new Error("Unexpected input type, only single file inputs are supported.");
            }

            const source = path.relative(process.cwd(), ev.input);
            const dest = path.relative(process.cwd(), ev.output[0]);
            process.stdout.write(green(`${source} => ${dest} [${ev.duration}ms]`) + "\n");
            ev.result.close();
        }

        // A build has encountered an error and been aborted.
        else if (ev.code === "ERROR") {
            displayError(ev.error);
        }
    });
}

/**
 * Executes a single build of the Obsidian project by using the rollup build
 * system.
 * 
 * @param options The options to pass to rollup for the build.
 */
async function build(options: RollupOptions[]): Promise<void> {
    process.stdout.write(`Compiling source files [0/${options.length}]`);

    // Each bundle is an element of the array, loop through each one and
    // compile/bundle.
    for (let i = 0; i < options.length; i++) {
        const optionsObj = options[i];

        try {
            let output: OutputOptions = Array.isArray(optionsObj.output) ? optionsObj.output[0] : optionsObj.output;

            const bundle = await rollup(optionsObj);
            await bundle.write(output);
            await bundle.close();
        }
        catch (error) {
            process.stdout.write("\n");
            displayError(error);

            process.exit(1);
        }

        process.stdout.write(`\rCompiling source files [${i + 1}/${options.length}]`);
    }

    process.stdout.write("\n");
}

const configFilePath = path.resolve(process.cwd(), "obsidian.config.json");

// Verify that the configuration file exists.
if (!existsSync(configFilePath)) {
    process.stderr.write("Configuration file obsidian.config.json was not found.");
    process.exit(1);
}

const config = require(configFilePath) as ObsidianOptions;

// Verify the configuration file is valid.
if (!config.source) {
    process.stderr.write("Must specify the source path of the files to compile.");
    process.exit(1);
}

const options = defineConfigs(path.resolve(process.cwd(), config.source), path.resolve(process.cwd(), "dist"), {
    copy: config.copy
});

const useWatch = process.argv.includes("--watch");

if (useWatch) {
    configureWatcher(watch(options));
}
else {
    build(options);
}
