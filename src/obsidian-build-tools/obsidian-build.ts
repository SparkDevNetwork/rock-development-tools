#!/usr/bin/env node

import { existsSync } from "fs";
import path from "path";
import process from "process";
import { Bundle, BundleBuilder, BundleError, clearScreen, defineConfigs, green, red, Watcher } from "./lib";

/**
 * The configuration options from the config file.
 */
interface ObsidianOptions {
    /** The folder that contains the source files to build. */
    source?: string;

    /** The base folder to copy all compiled bundles into. */
    destination?: string;

    /**
     * If set then the bundled files will be copied to the path specified by
     * destination.
     * */
    copy: boolean;
};

/**
 * Displays an error from rollup. This is patterned to display it the same way
 * it would be if it was generated by rollup directly.
 * 
 * @param error The error that should be displayed.
 */
function displayError(error: BundleError): void {
    let description = error.message || error;
    if (error.name) {
        description = `${error.name}: ${description}`;
    }

    process.stderr.write(`\n${red(`${description}`)}\n`);

    if (error instanceof BundleError) {
        process.stderr.write(`${path.relative(process.cwd(), error.filename)} (${error.line}:${error.column})\n\n`);
    }
}

/**
 * Creates a standard datestamp string for use in log messages.
 * 
 * @returns A string that describes the current date and time.
 */
function datestamp(): string {
    return new Date()
        .toISOString()
        .replace(/T/, " ")
        .replace(/\..+/, "");
}

/**
 * Configures the watcher by observing various events and responding to them.
 * 
 * @param watcher The rollup watcher that will be configured.
 */
async function watch(builders: BundleBuilder[]): Promise<void> {
    if (builders.length === 0) {
        process.stderr.write("No files found that need building, aborting watch.\n");
        return;
    }

    let buildTimeout: NodeJS.Timeout | undefined;
    let isBuilding = false;
    let queueBuild = false;

    function requestBuild() {
        if (isBuilding) {
            queueBuild = true;
            return;
        }

        if (buildTimeout !== undefined) {
            clearTimeout(buildTimeout);
        }

        buildTimeout = setTimeout(performBuild, 100);
    }

    async function performBuild(): Promise<void> {
        isBuilding = true;

        clearScreen();
        process.stdout.write(`[${datestamp()}] File change detected. Starting build.\n\n`);

        for (const wb of watchedBundles) {
            if (!wb.watcher.dirty) {
                continue;
            }

            try {
                const bundle = await wb.builder.build();

                const source = path.relative(process.cwd(), bundle.source);
                const dest = path.relative(process.cwd(), bundle.destination);
                process.stdout.write(green(`${source} => ${dest} [${bundle.duration}ms]`) + "\n");

                wb.watcher.updateWatchFiles(bundle.watchFiles);
            }
            catch (error) {
                displayError(error as BundleError);
            }

            wb.watcher.dirty = false;
        }

        process.stdout.write(`\n[${datestamp()}] Build complete. Waiting for changes.\n`);

        isBuilding = false;

        if (queueBuild) {
            queueBuild = false;
            buildTimeout = setTimeout(performBuild, 0);
        }
        else {
            buildTimeout = undefined;
        }
    }

    const watchedBundles: { builder: BundleBuilder, watcher: Watcher }[] = builders.map(builder => {
        const watcher = new Watcher(requestBuild);

        watcher.dirty = true;
        watcher.updateWatchFiles([builder.source]);

        return {
            builder,
            watcher
        };
    });

    await performBuild();
}

/**
 * Executes a single build of the Obsidian project by using the rollup build
 * system.
 * 
 * @param options The options to pass to rollup for the build.
 */
async function build(options: BundleBuilder[]): Promise<{ bundle: Bundle, builder: BundleBuilder }[]> {
    const results: { bundle: Bundle, builder: BundleBuilder }[] = [];

    process.stdout.write(`Compiling source files [0/${options.length}]`);

    // Each bundle is an element of the array, loop through each one and
    // compile/bundle.
    for (let i = 0; i < options.length; i++) {
        const builder = options[i];

        process.stdout.write(`\rCompiling source files [${i + 1}/${options.length}]`);

        try {
            const bundle = await builder.build();

            results.push({ bundle, builder });
        }
        catch (error) {
            process.stdout.write("\n");
            displayError(error as BundleError);

            process.exit(1);
        }
    }

    process.stdout.write("\n");

    return results;
}

let configFilePath = path.resolve(process.cwd(), "obsidian.config.json");
let useWatch = false;

for (let i = 0; i < process.argv.length; i++) {
    if (process.argv[i] === "--watch") {
        useWatch = true;
    }
    else if (process.argv[i] === "--config" && i + 1 < process.argv.length) {
        configFilePath = path.resolve(process.cwd(), process.argv[i + 1]);
        i++;
    }
}

// Verify that the configuration file exists.
if (!existsSync(configFilePath)) {
    process.stderr.write("Configuration file obsidian.config.json was not found.");
    process.exit(1);
}

const config = require(configFilePath) as ObsidianOptions;

// Verify the configuration file is valid.
if (!config.source) {
    process.stderr.write("Must specify the source path of the files to compile.");
    process.exit(1);
}

const builders = defineConfigs(path.resolve(path.dirname(configFilePath), config.source), path.resolve(path.dirname(configFilePath), "dist"), {
    copy: config.copy === true ? config.destination : undefined
});

if (useWatch) {
    watch(builders);
}
else {
    build(builders);
}
