#!/usr/bin/env node

import { existsSync } from "fs";
import path from "path";
import process from "process";
import { Bundle, BundleBuilder, BundleError, clearScreen, defineBuilders, green, red, StaticFileConfigOptions, Watcher, yellow } from "./lib";

/**
 * The configuration options from the config file.
 */
interface ObsidianOptions {
    /** The folder that contains the source files to build. */
    source?: string;

    /** The base folder to copy all compiled bundles into. */
    destination?: string;

    /**
     * If set then the bundled files will be copied to the path specified by
     * destination.
     * */
    copy: boolean;

    /**
     * The options to apply when processing static files.
     */
    staticFiles?: StaticFileConfigOptions;
};

/**
 * Displays an error from rollup. This is patterned to display it the same way
 * it would be if it was generated by rollup directly.
 * 
 * @param error The error that should be displayed.
 */
function displayError(error: BundleError): void {
    let description = error.message || error;
    if (error.name) {
        description = `${error.name}: ${description}`;
    }

    process.stderr.write(`${red(`${description}`)}\n`);

    if (error instanceof BundleError) {
        process.stderr.write(`${path.relative(process.cwd(), error.filename)} (${error.line}:${error.column})\n\n`);
    }
}

/**
 * Creates a standard datestamp string for use in log messages.
 * 
 * @returns A string that describes the current date and time.
 */
function datestamp(): string {
    return new Date()
        .toISOString()
        .replace(/T/, " ")
        .replace(/\..+/, "");
}

/**
 * Configures the watcher by observing various events and responding to them.
 * 
 * @param watcher The rollup watcher that will be configured.
 */
async function watch(builders: BundleBuilder[]): Promise<void> {
    if (builders.length === 0) {
        process.stderr.write("No files found that need building, aborting watch.\n");
        return;
    }

    let buildTimeout: NodeJS.Timeout | undefined;
    let isBuilding = false;
    let queueBuild = false;

    function requestBuild() {
        if (isBuilding) {
            queueBuild = true;
            return;
        }

        if (buildTimeout !== undefined) {
            clearTimeout(buildTimeout);
        }

        buildTimeout = setTimeout(performBuild, 100);
    }

    async function performBuild(): Promise<void> {
        isBuilding = true;

        const dirtyWatchedBundles = watchedBundles.filter(wb => wb.watcher.dirty);

        if (dirtyWatchedBundles.length > 0) {

            clearScreen();
            process.stdout.write(`[${datestamp()}] File change detected. Starting build.\n\n`);

            for (let i = 0; i < dirtyWatchedBundles.length; i++) {
                const wb = dirtyWatchedBundles[i];

                try {
                    const bundle = await wb.builder.build();

                    const source = path.relative(process.cwd(), bundle.source);
                    const dest = path.relative(process.cwd(), bundle.destination);
                    process.stdout.write(green(`[${i + 1}/${dirtyWatchedBundles.length}] ${source} => ${dest} [${bundle.duration}ms]`) + "\n");

                    wb.watcher.updateWatchFiles(bundle.watchFiles);
                }
                catch (error) {
                    const source = path.relative(process.cwd(), wb.builder.source);
                    process.stdout.write(red(`[${i + 1}/${dirtyWatchedBundles.length}] ${source}`) + "\n");

                    displayError(error as BundleError);
                }

                wb.watcher.dirty = false;
            }

            process.stdout.write(`\n[${datestamp()}] Build complete. Waiting for changes.\n`);
        }

        isBuilding = false;

        if (queueBuild) {
            queueBuild = false;
            buildTimeout = setTimeout(performBuild, 0);
        }
        else {
            buildTimeout = undefined;
        }
    }

    const watchedBundles: { builder: BundleBuilder, watcher: Watcher }[] = builders.map(builder => {
        const watcher = new Watcher(requestBuild);

        watcher.dirty = true;
        watcher.updateWatchFiles([builder.source]);

        return {
            builder,
            watcher
        };
    });

    await performBuild();
}

/**
 * Executes a single build of the Obsidian project by using the rollup build
 * system.
 * 
 * @param builders The bundle builders that need to be built.
 */
async function build(builders: BundleBuilder[]): Promise<{ bundle: Bundle, builder: BundleBuilder }[]> {
    const results: { bundle: Bundle, builder: BundleBuilder }[] = [];

    process.stdout.write(`[${datestamp()}] Starting build.\n\n`);

    // Each bundle is an element of the array, loop through each one and
    // compile/bundle.
    for (let i = 0; i < builders.length; i++) {
        const builder = builders[i];

        try {
            const bundle = await builder.build();

            const source = path.relative(process.cwd(), bundle.source);
            const dest = path.relative(process.cwd(), bundle.destination);
            process.stdout.write(green(`[${i + 1}/${builders.length}] ${source} => ${dest} (${bundle.duration}ms)`) + "\n");

            results.push({ bundle, builder });
        }
        catch (error) {
            const source = path.relative(process.cwd(), builder.source);
            process.stdout.write(red(`[${i + 1}/${builders.length}] ${source}`) + "\n");

            displayError(error as BundleError);

            process.exit(1);
        }
    }

    process.stdout.write(`\n[${datestamp()}] Build complete.\n`);

    return results;
}

function findEnvironmentPath(startingPath: string): string | undefined {
    let checkPath = startingPath;

    while (true) {
        if (existsSync(path.join(checkPath, "environment.json"))) {
            return path.relative(process.cwd(), checkPath).replace(/\\/g, '/');
        }

        const nextPath = path.dirname(checkPath);
        if (nextPath === checkPath) {
            return undefined;
        }

        checkPath = nextPath;
    }
}

async function main(): Promise<void> {
    let configFilePath = path.resolve(process.cwd(), "obsidian.config.json");
    let useWatch = false;

    for (let i = 0; i < process.argv.length; i++) {
        if (process.argv[i] === "--watch") {
            useWatch = true;
        }
        else if (process.argv[i] === "--config" && i + 1 < process.argv.length) {
            configFilePath = path.resolve(process.cwd(), process.argv[i + 1]);
            i++;
        }
    }

    // Verify that the configuration file exists.
    if (!existsSync(configFilePath)) {
        process.stderr.write("Configuration file obsidian.config.json was not found.");
        process.exit(1);
    }

    const config = require(configFilePath) as ObsidianOptions;

    // Verify the configuration file is valid.
    if (!config.source) {
        process.stderr.write("Must specify the source path of the files to compile.");
        process.exit(1);
    }

    if (config.destination && config.destination.includes("$(Environment)") && config.copy) {
        const environmentPath = findEnvironmentPath(path.dirname(configFilePath));

        if (!environmentPath) {
            process.stdout.write(yellow("Note: Environment not found, skipping copy phase.") + "\n");
            config.copy = false;
        }
        else {
            config.destination = config.destination.replace("$(Environment)", environmentPath);
        }
    }

    const builders = defineBuilders(path.resolve(path.dirname(configFilePath), config.source), path.resolve(path.dirname(configFilePath), "dist"), {
        copy: config.copy === true ? config.destination : undefined,
        staticFiles: config.staticFiles,
    });

    if (useWatch) {
        watch(builders);
    }
    else {
        await build(builders);
    }
}

main();
